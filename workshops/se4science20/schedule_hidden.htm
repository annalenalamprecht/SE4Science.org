<head>
	<meta name="author" content="Jeffrey Carver" />
	<meta http-equiv="content-type" content="text/html;charset=iso-8859-2" />
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
	<link rel="stylesheet" href="../images/conf-style.css" type="text/css" />
	<title>SE4Science'20</title>

	<style type="text/css">
.style1 {
	text-align: right;
}
	.auto-style1 {
		font-family: Arial, Sans-Serif;
		font-weight: bold;
		font-size: 18px;
		letter-spacing: 1px;
	}
	.with-space {
  	margin-bottom: 30px;
	}
	</style>
	<script src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
	<script>if(self != top) {top.location = self.location} else {document.documentElement.style.display = "block"}</script><script>if(self != top) {top.location = self.location}</script>
</head>
<body>
	<div class="content">
		<div class="header_top"></div>
		<div class="header">
			<div class="header_text">
				<span class="auto-style1">2020 International Workshop on Software Engineering for Computational Science</span>
				<h2>June 3-5, 2020</h2>
				<h2>Held in Conjunction with <a herf="https://www.iccs-meeting.org/iccs2020/">The International Conference on Computational Science</a><br></h2>
				<h2>Amsterdam<br><br></h2>
				<h2><a href="index.htm"><font color = "yellow">Home</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<a href="cfp.htm"><font color="yellow">Call for Papers</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<a href="committee.htm"><font color="yellow">Committee</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					Schedule
        	</div>
		</div>
		<div class="left">
		<div class="article">
<h2 align="center">Virtual Workshop</h2>
<br>
<h3 align="center">This workshop is online and asynchronous.</h3>
<h3 align="center">If you would like to participate in the discussion, please watch the videos, read the paper (linked from the paper title), and add your question as suggested text in the Google documents below.</h3>
<h3 align="center">The authors will respond to your comment as soon as possible. Please be aware that the authors may be in a different time zone and may not be able to respond to your comments immediately.</h3>
<h3 align="center">The discussion will continue, virtually, through June 12.</h3>



<div class="container">
	<div class="row row-cols-1 row-cols-md-3">
		<div class="col mb-4">
			<div class="card h-100">
				<iframe class="card-img-top" width="100%" src="https://www.youtube.com/embed/CVVbp2FJVZA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				<div class="card-body">
					<h4 class="card-title">
						<a href="https://arxiv.org/abs/2005.13227">Lessons learned in a decade of research software engineering GPU applications</a>
					</h4>
					<h6 class="card-subtitle mb-2 text-muted">Ben van Werkhoven, Willem Jan Palenstijn and Alessio Sclocco</h6>
					<p class="card-text">
						After years of using Graphics Processing Units (GPUs) to accelerate scientific applications in fields as varied as tomography, computer vision, climate modeling, digital forensics, geospatial databases, particle physics, radio astronomy, and localization microscopy, we noticed a number of technical, socio-technical, and non-technical challenges that Research Software Engineers (RSEs) may run into. While some of these challenges, such as managing different programming languages within a project, or having to deal with different memory spaces, are common to all software projects involving GPUs, others are more typical of scientific software projects. Among these challenges we include changing resolutions or scales, maintaining an application over time and making it sustainable, and evaluating both the obtained results and the achieved performance. %In this paper, we present the challenges and lessons learned from research software engineering GPU applications.
					</p>
				</div>
				<div class="card-footer">
					<a href="https://bit.ly/SE4S2020_1" class="btn btn-primary">Join the discussion</a>
					<a href="https://twitter.com/intent/tweet?button_hashtag=SE4Science&ref_src=twsrc%5Etfw&text=Asking @bvanwerkhoven @isazi about https://bit.ly/SE4S2020_1: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to authors
					</a>
				</div>
			</div>
		</div>

		<div class="col mb-4">
			<div class="card h-100">
				<iframe width="100%" src="https://www.youtube.com/embed/OHh_m-0pw3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				<div class="card-body">
					<h4 class="card-title">
						<a href="https://homepages.uc.edu/~niunn/papers/SE4Science20.pdf">Unit Tests of Scientific Software: A Study on SWMM</a>
					</h4>
					<h6 class="card-subtitle mb-2 text-muted">Zedong Peng, Xuanyi Lin and Nan Niu</h6>
					<p class="card-text">
						Testing helps assure software quality by executing program
						and uncovering bugs. Scientific software developers often find it challenging to carry out systematic and automated testing due to reasons like
						inherent model uncertainties and complex floating point computations.
						We report in this paper a manual analysis of the unit tests written by
						the developers of the Storm Water Management Model (SWMM). The
						results show that the 1,458 SWMM tests have a 54.0% code coverage and
						a 82.4% user manual coverage. We also observe a "getter-setter-getter"
						testing pattern from the SWMM unit tests. Based on these results, we
						offer insights to improve test development and coverage.
					</p>
				</div>
				<div class="card-footer">
					<a href="https://bit.ly/SE4S2020_2" class="btn btn-primary">Join the discussion</a>
					<a href="https://twitter.com/intent/tweet?screen_name=@pengzedong&ref_src=twsrc%5Etfw&text=Asking @pengzedong about https://bit.ly/SE4S2020_2: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to author
					</a>
				</div>
			</div>
		</div>

		<div class="col mb-4">
			<div class="card h-100">
				<iframe width="100%" src="https://www.youtube.com/embed/54XLXg4fYsc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				<div class="card-body">
					<h4 class="card-title">
						<a href="https://www.researchgate.net/publication/341132281_NUMA-Awareness_as_a_Plug-In_for_an_Eventify-based_Fast_Multipole_Method">NUMA-Awareness as a Plug-In for an Eventify-based Fast Multipole Method</a>
					</h4>
					<h6 class="card-subtitle mb-2 text-muted">Laura Morgenstern, David Haensel, Andreas Beckmann and Ivo Kabadshow</h6>
					<p class="card-text">
						Following the trend towards Exascale, today's supercomputers consist of increasingly complex and heterogeneous compute nodes. To exploit the performance of these systems, research software in HPC needs to keep up with the rapid development of hardware architectures. Since manual tuning of software to each and every architecture is neither sustainable nor viable, we aim to tackle this challenge through appropriate software design. In this article, we aim to improve the performance and sustainability of FMSolvr, a parallel Fast Multipole Method for Molecular Dynamics, by adapting it to Non-Uniform Memory Access architectures in a portable and maintainable way. The parallelization of FMSolvr is based on Eventify, an event-based tasking framework we co-developed with FMSolvr. We describe a layered software architecture that enables the separation of the Fast Multipole Method from its paral-lelization. The focus of this article is on the development and analysis of a reusable NUMA module that improves performance while keeping both layers separated to preserve maintainability and extensibility. By means of the NUMA module we introduce diverse NUMA-aware data distribution , thread pinning and work stealing policies for FMSolvr. During the performance analysis the modular design of the NUMA module was advantageous since it facilitates combination, interchange and redesign of the developed policies. The performance analysis reveals that the run-time of FMSolvr is reduced by 21% from 1.48 ms to 1.16 ms through these policies.
					</p>
				</div>
				<div class="card-footer">
					<a href="https://bit.ly/SE4S2020_3" class="btn btn-primary">Join the discussion</a>
					<a href="https://twitter.com/intent/tweet?screen_name=@LaMorgenstern&ref_src=twsrc%5Etfw&text=Asking @LaMorgenstern about https://bit.ly/SE4S2020_3: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to author
					</a>
				</div>
			</div>
		</div>

		<div class="col mb-4">
			<div class="card h-100">
			  <iframe width="100%" src="https://www.youtube.com/embed/54XLXg4fYsc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
			  <div class="card-body">
			    <h4 class="card-title">
						<a href="http://ts.iup.uni-heidelberg.de/fileadmin/user_upload/Yunus_Sevinchan/Sevinchan2020-boosting-group-level-synergies-preprint.pdf">Boosting Group-level Synergies by Using a Shared Modeling Framework</a>
					</h4>
			    <h6 class="card-subtitle mb-2 text-muted">Yunus Sevinchan, Benjamin Herdeanu, Harald Mack, Lukas Riedel and Kurt Roth</h6>
			    <p class="card-text">
						Modern software engineering has established sophisticated
						tools and workflows that enable distributed development of high-quality
						software. Here, we present our experiences in adopting these workflows
						to collectively develop, maintain, and use research software, specifically:
						a modeling framework for complex and evolving systems. We exemplify
						how sharing this modeling framework within our research group helped
						conveying software engineering best practices, fostered cooperation, and
						boosted synergies. Together, these experiences illustrate that the adoption of modern software engineering workflows is feasible in the dynamically changing academic context, and how these practices facilitate reliability, reproducibility, reusability, and sustainability of research software,
						ultimately improving the quality of the resulting scientific output.
			    </p>
			  </div>
			  <div class="card-footer">
			    <a href="https://bit.ly/SE4S2020_4" class="btn btn-primary">Join discussion</a>
					<a href="https://twitter.com/intent/tweet?button_hashtag=SE4Science&ref_src=twsrc%5Etfw&text=Asking the authors about https://bit.ly/SE4S2020_4: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to author
					</a>
			  </div>
			</div>
		</div>

		<div class="col mb-4">
			<div class="card h-100">
			  <iframe width="100%" src="https://www.youtube.com/embed/54XLXg4fYsc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
			  <div class="card-body">
			    <h4 class="card-title">
						<a href="http://carver.cs.ua.edu/Papers/Workshop/2020/2020_SE4Science_Testing_LANL.pdf">Testing Research Software: A Case Study</a>
					</h4>
			    <h6 class="card-subtitle mb-2 text-muted">Nasir Eisty, Danny Perez, Jeffrey Carver, J. David Moulton and Hai Ah Nam</h6>
			    <p class="card-text">
						<i>Background</i>: The increasing importance of software for the
						conduct of various types of research raises the necessity of proper testing
						to ensure correctness. The unique characteristics of the research software
						produce challenges in the testing process that require attention.
						<i>Aims</i>:
						Therefore, the goal of this paper is to share the experience of implementing a testing framework using a statistical approach for a specific type
						of research software, i.e. non-deterministic software.
						<i>Method</i>: Using the
						ParSplice research software project as a case, we implemented a testing
						framework based on a statistical testing approach called Multinomial
						Test.
						<i>Results</i>: Using the new framework, we were able to test the ParSplice project and demonstrate correctness in a situation where traditional methodical testing approaches were not feasible. Conclusions: This
						study opens up the possibilities of using statistical testing approaches for
						research software that can overcome some of the inherent challenges involved in testing non-deterministic research software.
			    </p>
			  </div>
			  <div class="card-footer">
			    <a href="https://bit.ly/SE4S2020_5" class="btn btn-primary">Join the discussion</a>
					<a href="https://twitter.com/intent/tweet?screen_name=@nasireisty&ref_src=twsrc%5Etfw&text=Asking @nasireisty @jeffcarver32 @HaiAhNam1 about https://bit.ly/SE4S2020_5: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to authors
					</a>
			  </div>
			</div>
		</div>

		<div class="col mb-4">
			<div class="card h-100">
			  <iframe width="100%" src="https://www.youtube.com/embed/CzecqRJXmoM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
			  <div class="card-body">
			    <h4 class="card-title">
						<a href="https://www.ris.uu.nl/ws/files/72183383/paper_648.pdf">APE: A Command-Line Tool and API for Automated Workflow Composition</a>
					</h4>
			    <h6 class="card-subtitle mb-2 text-muted">Vedran Kasalica and Anna-Lena Lamprecht</h6>
			    <p class="card-text">
						Automated workflow composition is bound to take the work
						with scientific workflows to the next level. On top of today's comprehensive eScience infrastructure, it enables the automated generation of
						possible workflows for a given specification. However, functionality for
						automated workflow composition tends to be integrated with one of the
						many available workflow management systems, and is thus difficult or
						impossible to apply in other environments. Therefore we have developed
						APE (the Automated Pipeline Explorer) as a command-line tool and
						API for automated composition of scientific workflows. APE is easily
						configured to a new application domain by providing it with a domain
						ontology and semantically annotated tools. It can then be used to synthesize purpose-specific workflows based on a specification of the available
						workflow inputs, desired outputs and possibly additional constraints. The
						workflows can further be transformed into executable implementations
						and/or exported into standard workflow formats. In this paper we describe APE v1.0 and discuss lessons learned from applications in bioinformatics and geosciences.
			    </p>
			  </div>
			  <div class="card-footer">
			    <a href="https://bit.ly/SE4S2020_6" class="btn btn-primary">Join the discussion</a>
					<a href="https://twitter.com/intent/tweet?screen_name=@vkasalica&ref_src=twsrc%5Etfw&text=Asking @vkasalica @al_lamprecht about https://bit.ly/SE4S2020_6: ..." class="btn btn-primary">
						<i class="fab fa-twitter"></i> Tweet to authors
					</a>
			  </div>
			</div>
		</div>

	</div>
</div>

<br>
<hr>
<em>Last Updated on May 29, 2020 by Jeffrey Carver</em></div>
		</div>
		<div class="header_bottom"></div>
		<div class="footer">
			<p><a href="http://www.ua.edu">University of Alabama </a> | <a href="http://www.eng.ua.edu/">College of Engineering </a> | <a href="http://cs.ua.edu/">Department of Computer Science</a><br />
		  &copy; Copyright 2020 University of Alabama <a href="http://www.solucija.com/" title="What's your solution?"></a></p>
	  </div>
	</div>
	<Br>
</body>
</html>
